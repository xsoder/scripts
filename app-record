#!/usr/bin/env bash

pidfile="/tmp/window_record_ffmpeg.pid"

if [ -f "$pidfile" ]; then
  pid=$(cat "$pidfile")
  if kill -0 "$pid" 2>/dev/null; then
    notify-send "Screen Recorder" "Stopping recording (PID $pid)..."
    kill -INT "$pid"
    rm "$pidfile"
    exit 0
  else
    notify-send "Screen Recorder" "Stale PID file found. Removing."
    rm "$pidfile"
  fi
fi

# No running recording, start new one:

# List windows
mapfile -t windows < <(xdotool search --onlyvisible --name ".")

window_list=()
for win_id in "${windows[@]}"; do
  title=$(xdotool getwindowname "$win_id")
  window_list+=("$win_id: $title")
done

selected=$(printf '%s\n' "${window_list[@]}" | dmenu -i -p "Select window to record:")

if [ -z "$selected" ]; then
  notify-send "Screen Recorder" "No window selected."
  exit 1
fi

win_id="${selected%%:*}"

eval $(xdotool getwindowgeometry --shell "$win_id")
X=$(( X < 0 ? 0 : X ))
Y=$(( Y < 0 ? 0 : Y ))

output_dir="$HOME/media/Videos/Recordings"
mkdir -p "$output_dir"
output_file="$output_dir/${win_id}_$(date +%F_%T).mkv"

notify-send "Screen Recorder" "Starting recording of window ID $win_id..."

# Start ffmpeg in background and save its PID
ffmpeg -video_size "${WIDTH}x${HEIGHT}" -framerate 60 -f x11grab -i ":0.0+${X},${Y}" -c:v libx264 -preset ultrafast -crf 18 "$output_file" &

echo $! > "$pidfile"
notify-send "Screen Recorder" "Recording started. Run the script again to stop."

